# KollabSpace Drawing API Contract

## Overview
Real-time collaborative drawing feature using WebSocket (STOMP protocol) for live updates and REST API for loading canvas history.

**Backend Server:** `http://localhost:8080`
**WebSocket Endpoint:** `ws://localhost:8080/ws` (with SockJS fallback)

---

## WebSocket Connection Setup

### Required JavaScript Libraries
```html
<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
```

### Connection Example
```javascript
const socket = new SockJS('http://localhost:8080/ws');
const stompClient = Stomp.over(socket);

stompClient.connect({}, function(frame) {
    console.log('Connected: ' + frame);

    // Subscribe to canvas updates
    stompClient.subscribe('/topic/canvas/{canvasId}', function(message) {
        const data = JSON.parse(message.body);
        handleCanvasUpdate(data);
    });
});
```

### STOMP Routing
- **Client sends to:** `/app/canvas/{canvasId}/*` (application destination)
- **Server broadcasts to:** `/topic/canvas/{canvasId}` (broker destination)
- **All subscribers receive:** Real-time updates on the topic

---

## Data Models

### DrawingStrokeRequestDTO (What Client Sends)
**IMPORTANT:** When sending a stroke, DO NOT include `id` or `timestamp` - the server generates these!

```typescript
interface DrawingStrokeRequestDTO {
  canvasId: string;     // Canvas identifier (required)
  points: Point[];      // Array of coordinate points (required, not empty)
  color: string;        // Hex color e.g., "#FF5733" (required)
  width: number;        // Stroke width e.g., 2.5 (required)
  userId: string;       // User who created the stroke (required)
}
```

### DrawingStroke (Server Response)
```typescript
interface DrawingStroke {
  id: string;           // UUID generated by server ✅
  canvasId: string;     // Canvas identifier
  points: Point[];      // Array of coordinate points
  color: string;        // Hex color (e.g., "#FF5733")
  width: number;        // Stroke width (e.g., 2.5)
  userId: string;       // User who created the stroke
  timestamp: number;    // Unix timestamp in milliseconds ✅
}
```

### Point
```typescript
interface Point {
  x: number;  // X coordinate (integer)
  y: number;  // Y coordinate (integer)
}
```

### DeleteStrokeRequest
```typescript
interface DeleteStrokeRequest {
  strokeId: string;  // ID of stroke to delete
}
```

### DeleteStrokeMessage (Server Response)
```typescript
interface DeleteStrokeMessage {
  strokeId: string;  // ID of deleted stroke
}
```

### ClearCanvasMessage (Server Response)
```typescript
interface ClearCanvasMessage {
  canvasId: string;  // ID of cleared canvas
}
```

---

## WebSocket API Endpoints

### 1. Add Stroke (Drawing)

**Client sends to:** `/app/canvas/{canvasId}/stroke`
**Server broadcasts to:** `/topic/canvas/{canvasId}`

**Request Payload:**
```json
{
  "canvasId": "canvas123",
  "points": [
    {"x": 100, "y": 150},
    {"x": 102, "y": 152},
    {"x": 105, "y": 155}
  ],
  "color": "#FF5733",
  "width": 3.0,
  "userId": "user-alice"
}
```

**Server Response (Broadcast to all subscribers):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "canvasId": "canvas123",
  "points": [
    {"x": 100, "y": 150},
    {"x": 102, "y": 152},
    {"x": 105, "y": 155}
  ],
  "color": "#FF5733",
  "width": 3.0,
  "userId": "user-alice",
  "timestamp": 1701234567890
}
```

**Notes:**
- Server automatically generates `id` (UUID) and `timestamp`
- All subscribers (including sender) receive the complete stroke object
- Points array should contain the path drawn by the user

---

### 2. Delete Stroke (Eraser/Undo)

**Client sends to:** `/app/canvas/{canvasId}/delete`
**Server broadcasts to:** `/topic/canvas/{canvasId}`

**Request Payload:**
```json
{
  "strokeId": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Server Response (Broadcast to all subscribers):**
```json
{
  "strokeId": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Notes:**
- Server removes the stroke from storage
- All clients should remove this stroke from their canvas
- If stroke doesn't exist, operation is silently ignored

---

### 3. Clear Canvas

**Client sends to:** `/app/canvas/{canvasId}/clear`
**Server broadcasts to:** `/topic/canvas/{canvasId}`

**Request Payload:** Empty object
```json
{}
```

**Server Response (Broadcast to all subscribers):**
```json
{
  "canvasId": "canvas123"
}
```

**Notes:**
- Removes ALL strokes from the canvas
- All clients should clear their entire canvas

---

## REST API Endpoint

### Get Canvas History (Load Existing Strokes)

**Endpoint:** `GET /api/canvas/{canvasId}/strokes`
**Method:** HTTP GET
**Returns:** Array of DrawingStroke objects

**Example Request:**
```javascript
fetch('http://localhost:8080/api/canvas/canvas123/strokes')
  .then(response => response.json())
  .then(strokes => {
    console.log('Loaded strokes:', strokes);
    strokes.forEach(stroke => renderStroke(stroke));
  });
```

**Example Response:**
```json
[
  {
    "id": "uuid-1",
    "canvasId": "canvas123",
    "points": [{"x": 10, "y": 20}, {"x": 30, "y": 40}],
    "color": "#000000",
    "width": 2.0,
    "userId": "user-alice",
    "timestamp": 1701234567890
  },
  {
    "id": "uuid-2",
    "canvasId": "canvas123",
    "points": [{"x": 50, "y": 60}, {"x": 70, "y": 80}],
    "color": "#FF0000",
    "width": 5.0,
    "userId": "user-bob",
    "timestamp": 1701234568000
  }
]
```

**Notes:**
- Returns empty array `[]` if canvas is new
- Use this endpoint on initial connection to load existing strokes
- Strokes are ordered by creation time

---

## Complete Client Implementation Example

```javascript
// ===== SETUP =====
const CANVAS_ID = 'canvas123';
const USER_ID = 'user-' + Math.random().toString(36).substr(2, 9);
let stompClient = null;
let isDrawing = false;
let currentStroke = [];
let currentColor = '#000000';
let currentWidth = 2;

// Canvas elements
const canvas = document.getElementById('drawingCanvas');
const ctx = canvas.getContext('2d');

// ===== WEBSOCKET CONNECTION =====
function connect() {
    const socket = new SockJS('http://localhost:8080/ws');
    stompClient = Stomp.over(socket);

    stompClient.connect({}, function(frame) {
        console.log('Connected: ' + frame);

        // Subscribe to canvas updates
        stompClient.subscribe('/topic/canvas/' + CANVAS_ID, function(message) {
            const data = JSON.parse(message.body);
            handleServerMessage(data);
        });

        // Load existing strokes
        loadCanvasHistory();
    });
}

// ===== LOAD HISTORY =====
function loadCanvasHistory() {
    fetch(`http://localhost:8080/api/canvas/${CANVAS_ID}/strokes`)
        .then(res => res.json())
        .then(strokes => {
            console.log('Loaded strokes:', strokes);
            strokes.forEach(stroke => renderStroke(stroke));
        });
}

// ===== HANDLE SERVER MESSAGES =====
function handleServerMessage(data) {
    // Check message type by its structure
    if (data.points && data.color) {
        // It's a DrawingStroke
        renderStroke(data);
    } else if (data.strokeId && !data.canvasId) {
        // It's a DeleteStrokeMessage
        console.log('Stroke deleted:', data.strokeId);
        // In a real app, you'd remove this stroke from your data structure
        // and potentially redraw the canvas
    } else if (data.canvasId && !data.strokeId) {
        // It's a ClearCanvasMessage
        console.log('Canvas cleared');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
}

// ===== SEND STROKE TO SERVER =====
function sendStroke(points, color, width) {
    if (!stompClient || points.length === 0) return;

    const strokeData = {
        canvasId: CANVAS_ID,
        points: points,
        color: color,
        width: width,
        userId: USER_ID
    };

    stompClient.send('/app/canvas/' + CANVAS_ID + '/stroke', {},
        JSON.stringify(strokeData));
}

// ===== DELETE STROKE =====
function deleteStroke(strokeId) {
    if (!stompClient) return;

    stompClient.send('/app/canvas/' + CANVAS_ID + '/delete', {},
        JSON.stringify({ strokeId: strokeId }));
}

// ===== CLEAR CANVAS =====
function clearCanvas() {
    if (!stompClient) return;

    stompClient.send('/app/canvas/' + CANVAS_ID + '/clear', {},
        JSON.stringify({}));
}

// ===== RENDER STROKE ON CANVAS =====
function renderStroke(stroke) {
    if (stroke.points.length === 0) return;

    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    ctx.beginPath();
    ctx.moveTo(stroke.points[0].x, stroke.points[0].y);

    for (let i = 1; i < stroke.points.length; i++) {
        ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
    }

    ctx.stroke();
}

// ===== MOUSE EVENTS (DRAWING) =====
canvas.addEventListener('mousedown', function(e) {
    isDrawing = true;
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor(e.clientX - rect.left);
    const y = Math.floor(e.clientY - rect.top);
    currentStroke = [{x: x, y: y}];
});

canvas.addEventListener('mousemove', function(e) {
    if (!isDrawing) return;

    const rect = canvas.getBoundingClientRect();
    const x = Math.floor(e.clientX - rect.left);
    const y = Math.floor(e.clientY - rect.top);
    currentStroke.push({x: x, y: y});

    // Draw locally (optimistic update)
    if (currentStroke.length > 1) {
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const prev = currentStroke[currentStroke.length - 2];
        const curr = currentStroke[currentStroke.length - 1];

        ctx.beginPath();
        ctx.moveTo(prev.x, prev.y);
        ctx.lineTo(curr.x, curr.y);
        ctx.stroke();
    }
});

canvas.addEventListener('mouseup', function() {
    if (isDrawing && currentStroke.length > 0) {
        // Send stroke to server
        sendStroke(currentStroke, currentColor, currentWidth);
        currentStroke = [];
    }
    isDrawing = false;
});

// ===== START APPLICATION =====
connect();
```

---

## Message Flow Example

### Scenario: User Alice draws a line

```
1. Alice's Client                 Server                  Bob's Client
   │                                │                         │
   │  mousedown (start drawing)     │                         │
   │  mousemove (collect points)    │                         │
   │  mouseup                        │                         │
   │                                 │                         │
   │  SEND /app/canvas/123/stroke   │                         │
   ├───────────────────────────────>│                         │
   │                                 │                         │
   │                                 │ Process & save stroke   │
   │                                 │ Generate ID & timestamp │
   │                                 │                         │
   │  Broadcast DrawingStroke        │                         │
   │<────────────────────────────────┤                         │
   │                                 ├────────────────────────>│
   │                                 │                         │
   │  Render stroke                  │                  Render stroke
   │  (already drawn optimistically) │                  (draws on canvas)
```

---

## Canvas Behavior

### Canvas Isolation
- Each `canvasId` maintains separate stroke storage
- Messages on `/topic/canvas/canvas123` don't affect `/topic/canvas/canvas456`
- Multiple canvases can exist simultaneously

### Storage Limits
- **Max strokes per canvas:** 1000
- When limit exceeded, oldest strokes are automatically removed (FIFO)
- In-memory storage (data lost on server restart)

### Stroke Properties
- **Immutable:** Once created, strokes cannot be edited
- **Operations:** Add, Delete, or Clear only
- **Unique IDs:** Server-generated UUIDs prevent conflicts

---

## Recommended Frontend Architecture

### Drawing Tools to Implement
1. **Pen** - Free-form drawing (collect points on mousemove)
2. **Eraser** - Delete strokes by clicking on them
3. **Clear All** - Clear entire canvas for everyone
4. **Color Picker** - Change stroke color (hex format)
5. **Width Slider** - Adjust stroke width (1-20 recommended)

### User Experience Tips
1. **Optimistic Updates:** Draw locally immediately, then send to server
2. **User Colors:** Assign each user a consistent color for their strokes
3. **Cursor Indicators:** Show other users' cursors (requires custom implementation)
4. **Undo:** Track stroke IDs you create, send delete requests to undo
5. **History:** Load canvas history on connection before allowing drawing

### Error Handling
1. **Connection Loss:** Detect disconnection, show warning, attempt reconnect
2. **Failed Messages:** STOMP doesn't guarantee delivery - consider acknowledgments
3. **Concurrent Edits:** Last-write-wins (no conflict resolution needed)

---

## Differences from Chat Feature

| Feature | Chat | Drawing |
|---------|------|---------|
| **Pattern** | Append-only | Object-based |
| **Conflicts** | None (messages are independent) | None (strokes are independent) |
| **Operations** | Add only | Add, Delete, Clear |
| **Data Size** | Small (text messages) | Larger (point arrays) |
| **History** | Linear (ordered list) | Spatial (canvas rendering) |
| **Editing** | No editing | No editing (delete + recreate) |

---

## Testing Checklist

### Basic Functionality
- [ ] Connect to WebSocket successfully
- [ ] Load existing canvas history on connect
- [ ] Draw a stroke and see it appear locally
- [ ] Receive stroke from another user and render it
- [ ] Delete a stroke and see it removed
- [ ] Clear canvas and see all strokes removed

### Multi-User Scenarios
- [ ] Open two browser tabs with same canvasId
- [ ] Draw in Tab 1, see it appear in Tab 2
- [ ] Draw in Tab 2, see it appear in Tab 1
- [ ] Delete stroke in Tab 1, see it removed in Tab 2
- [ ] Clear canvas in Tab 1, see Tab 2 canvas cleared

### Edge Cases
- [ ] Disconnect and reconnect (should reload history)
- [ ] Draw with 0 points (should be ignored)
- [ ] Delete non-existent stroke (should be silently ignored)
- [ ] Rapidly draw many strokes (stress test)
- [ ] Use different colors and widths
- [ ] Multiple users drawing simultaneously

---

## Technical Notes

### Thread Safety
- Server uses `ConcurrentHashMap` for thread-safe stroke storage
- Each WebSocket connection runs in a separate thread
- No race conditions on concurrent stroke additions

### Performance Considerations
- **Point Array Size:** Limit points per stroke (suggest < 1000 points)
- **Stroke Count:** Max 1000 strokes per canvas (oldest removed automatically)
- **Rendering:** Consider using `requestAnimationFrame` for smooth drawing
- **Network Traffic:** Debounce mousemove to reduce point density

### Browser Compatibility
- Requires WebSocket support (all modern browsers)
- SockJS provides fallback for older browsers
- HTML5 Canvas required for rendering

---

## Example HTML Starter Template

```html
<!DOCTYPE html>
<html>
<head>
    <title>KollabSpace Drawing</title>
    <style>
        #drawingCanvas {
            border: 1px solid black;
            cursor: crosshair;
        }
        .controls {
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Collaborative Drawing</h1>

    <div class="controls">
        <label>Color: <input type="color" id="colorPicker" value="#000000"></label>
        <label>Width: <input type="range" id="widthSlider" min="1" max="20" value="2"></label>
        <button onclick="clearCanvas()">Clear Canvas</button>
    </div>

    <canvas id="drawingCanvas" width="800" height="600"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
    <script>
        // Insert JavaScript implementation here (see Complete Client Implementation Example above)
    </script>
</body>
</html>
```

---

## Questions or Issues?

If you encounter any issues or have questions about the API:
1. Check server logs for error messages
2. Verify STOMP connection is established
3. Ensure message payloads match the expected format
4. Test REST endpoint separately with curl/Postman first

---

**Last Updated:** 2025-12-06
**Backend Version:** 0.0.1-SNAPSHOT
**Spring Boot Version:** 4.0.0
